/// <reference types="bn.js" />
import { ApiPromise } from "@polkadot/api";
import { H256, EventRecord } from "@polkadot/types/interfaces/types";
import { BN } from "@polkadot/util";
import { KeyringPair } from "@polkadot/keyring/types";
import * as TransactionData from "./../transaction_data";
import { WaitFor, GenericFailure, TransactionOptions } from "./common";
export type DispatchFeeModifier = {
    weightMaximumFee: BN | null;
    weightFeeDivider: number | null;
    weightFeeMultiplier: number | null;
};
type SubmitDataTxSuccess = {
    isErr: false;
    txData: TransactionData.DataAvailability.SubmitData;
    event: Events.DataSubmittedEvent;
    events: EventRecord[];
    txHash: H256;
    txIndex: number;
    blockHash: H256;
    blockNumber: number;
};
type CreateApplicationKeyTxSuccess = {
    isErr: false;
    event: Events.ApplicationKeyCreatedEvent;
    events: EventRecord[];
    txHash: H256;
    txIndex: number;
    blockHash: H256;
    blockNumber: number;
};
type SetApplicationKeyTxSuccess = {
    isErr: false;
    event: Events.ApplicationKeySetEvent;
    events: EventRecord[];
    txHash: H256;
    txIndex: number;
    blockHash: H256;
    blockNumber: number;
};
type SubmitBlockLengthProposalTxSuccess = {
    isErr: false;
    event: Events.BlockLengthProposalSubmittedEvent;
    events: EventRecord[];
    txHash: H256;
    txIndex: number;
    blockHash: H256;
    blockNumber: number;
};
type SetSubmitDataFeeModifierTxSuccess = {
    isErr: false;
    event: Events.SubmitDataFeeModifierSetEvent;
    events: EventRecord[];
    txHash: H256;
    txIndex: number;
    blockHash: H256;
    blockNumber: number;
};
export declare class DataAvailability {
    private api;
    constructor(api: ApiPromise);
    submitData(data: string, waitFor: WaitFor, account: KeyringPair, options?: TransactionOptions): Promise<SubmitDataTxSuccess | GenericFailure>;
    createApplicationKey(key: string, waitFor: WaitFor, account: KeyringPair, options?: TransactionOptions): Promise<CreateApplicationKeyTxSuccess | GenericFailure>;
    setApplicationKey(oldKey: string, newKey: string, waitFor: WaitFor, account: KeyringPair, options?: TransactionOptions): Promise<SetApplicationKeyTxSuccess | GenericFailure>;
    submitBlockLengthProposal(rows: number, cols: number, waitFor: WaitFor, account: KeyringPair, options?: TransactionOptions): Promise<SubmitBlockLengthProposalTxSuccess | GenericFailure>;
    setSubmitDataFeeModifier(modifier: DispatchFeeModifier, waitFor: WaitFor, account: KeyringPair, options?: TransactionOptions): Promise<SetSubmitDataFeeModifierTxSuccess | GenericFailure>;
}
export declare namespace Events {
    class DataSubmittedEvent {
        who: string;
        dataHash: string;
        constructor(who: string, dataHash: string);
        static New(events: EventRecord[]): DataSubmittedEvent | undefined;
    }
    class ApplicationKeyCreatedEvent {
        key: string;
        owner: string;
        id: string;
        constructor(key: string, owner: string, id: string);
        static New(events: EventRecord[]): ApplicationKeyCreatedEvent | undefined;
    }
    class ApplicationKeySetEvent {
        oldKey: string;
        newKey: string;
        constructor(oldKey: string, newKey: string);
        static New(events: EventRecord[]): ApplicationKeySetEvent | undefined;
    }
    class BlockLengthProposalSubmittedEvent {
        rows: string;
        cols: string;
        constructor(rows: string, cols: string);
        static New(events: EventRecord[]): BlockLengthProposalSubmittedEvent | undefined;
    }
    class SubmitDataFeeModifierSetEvent {
        weightMaximumFee: BN | null;
        weightFeeDivider: string | null;
        weightFeeMultiplier: string | null;
        constructor(weightMaximumFee: BN | null, weightFeeDivider: string | null, weightFeeMultiplier: string | null);
        static New(events: EventRecord[]): SubmitDataFeeModifierSetEvent | undefined;
    }
}
export {};
